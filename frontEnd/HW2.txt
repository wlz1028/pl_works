#2

1)O(N1+N2)
j=1
k=1
L3=new empty list contains L1nL2
for i:1...N1 do
	if L1[i]=L2[j]
		L3[k]=L1[i]
		k++
		i++
	else if L1[i]>L2[j]
		j++
	else
		i++
end


2)O(min(N1,N2)log(max(N1,N2))

if N2>=N1
	N2=Nmax
	L2=Lmax
	N1=Nmin
	L1=Lmin
else
	N1=Nmax
	L1=Lmax
	N2=Nmin
	L2=Lmin

binary_search(A, key, imin, imax)

for i:1...Nmin do
	FOUNDED=binary_search(Lmax,Lmin[i],1,Nmax)
	if FOUNDED
		New_List=New_list?FOUNDED
end
------------------------
#3
if Black_Box(S,k)=false
	return false
else
	O={}
	for i...n
		S=S-S[i]
		if Black_Box(S,S[i])=true
			O=O?S[i]
		else
			return false
	end
return O

-----------------------
#4
a)
MeargeSort(Smax)
for i:1...Nmin do
	FOUNDED=binary_search(Smax,x-Smin[i],0,Nmax)
end

b)
MeargeSort(Smax)
for i:1...Nmin do
	FOUNDED=binary_search(Lmax,Lmin[i],1,Nmax)
end


-------------
#5

K-TH_LARGEST=Check_Next_Row(TREE,[1],TREE[1],0,KTH)

int Check_Next_Row(TREE,index_list,min,k,KTH)
new_index_list=[]
for (i=1;i<=len(index_list);i++)
	if (TREE[index_list[i].left]>=min)
		k++
		min=TREE[index_list[i].left]
		new_index_list+=index_list[i].left
	if (TREE[index[i].right]>=min)
		k++
		min=TREE[index[i].right]
		new_index_list+=index[i].right
end

if k>=KTH
	return min
else
	return Check_Next_Row(TREE,new_index_list[],min,k,KTH)

end